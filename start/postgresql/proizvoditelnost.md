---
order: 3
title: Производительность
---

Включение **pg_stat_statements**

Чтобы включить данную библиотеку требуется в файле postgresql.conf вписать строки

shared_preload_libraries = ‘pg_stat_statements‘

pg_stat_statements.track = 'all'

pg_stat_statements.max = 10000

Далее перезапустить кластер чтобы изменения вступили в силу или SELECT pg_reload_conf();



Включить сбор статистики

Выполнить запрос CREATE EXTENSION pg_stat_statements;

Полезные запросы:



**Запрос 1.**

SELECT\
round(100 \* sum(blks_hit) / sum(blks_hit + blks_read), 3) as cache_hit_ratio\
FROM pg_stat_database;

Первое, что мы можем посмотреть – это процент попадания в кэш. Процент попадания в кэш – это полезная метрика. Она позволяет оценить, какой объем данных берется из кэша shared buffers, а какой объем читается с диска. **Чем большее у нас попадание в кэш, то тем лучше**.



**Запрос 2.**

Посмотреть самые трудоемкие запросы

SELECT substring(query, 1, 50) AS short_query,\
round(total_exec_time::numeric, 2) AS total_time,\
calls,\
round(mean_exec_time::numeric, 2) AS mean,\
round((100 \* total_exec_time / sum(total_exec_time::numeric) OVER ())::numeric, 2) AS percentage_cpu\
FROM pg_stat_statements\
ORDER BY total_time DESC\
LIMIT 20;



**Запрос 3**

select \* from pg_stat_bgwriter;

Если вы видите, что у вас параметр `maxwritten_clean` большой, это значит, что background writer не справляется со своей работой и нужно увеличивать параметры `bgwriter_lru_maxpages`, чтобы он смог за один цикл сделать больше работы, больше очистить страничек.



**Запрос 4**

select sum(temp_files) as temp_files, pg_size_pretty(sum(temp_bytes)) as temp_size from pg_stat_database;

Максимальный лимит памяти, который выделяется для обработки запросов. То есть, каждый запрос сможет получить этот объём памяти. Для **1С**, мне кажется, должно хватить **512MB** (если столько есть физически на каждое соединение). То есть: **work_mem = 512MB**.

Если для запроса не хватит **work_mem** памяти, то запрос будет использовать **временные файлы на диске**, поэтому стоит следить за их количеством.

Если временных файлов нет, значит всё хорошо.

Есть формула по которой можно вычислить максимальное значение для **work_mem**: (вся память -- shared_bufer) / максимальное\_количество\_соединений.

С помощью такого запроса можно узнать количество соединений в данный момент:

***SELECT COUNT(\*) as connections,***

***backend_type***

***FROM pg_stat_activity***

***where state = 'active' OR state = 'idle'***

***GROUP BY backend_type***

***ORDER BY connections DESC;***

Представим ситуацию, у вас **30GB всего** памяти, на **shared_bufer выделили 8GB**. Вычислили, что **соединений** в процессе работы максимально **было 15**. Значит высчитываем (30 -- 8) / 15 = **1,46GB**. Это довольно много, поэтому можем уменьшить и указать -- **work_mem = 512MB**.

Затем понаблюдаем, не растёт ли количество временных файлов. Если не растёт, то всё хорошо. А если растёт, то можно немного увеличить значение, но не делать его больше чем 1,46GB.

Перезагрузить temp_files и temp_size: select pg_stat_reset();





**Столбцы pg_stat_statements**

| **Столбцы**                | **Тип столбца**                  | **Описание**                                                                                                                                                           |
|----------------------------|----------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **userid**                 | **oid(ссылки pg_authid. oid)**   | **OID пользователя, выполнившего оператор**                                                                                                                            |
| **dbid**                   | **oid(ссылки pg_database. oid)** | **OID базы данных, в которой был выполнен оператор**                                                                                                                   |
| **toplevel**               | **bool**                         | **Истинно, если запрос был выполнен как оператор верхнего уровня (всегда истинно, если pg_stat_statements.track установлено значение top)**                            |
| **queryid**                | **bigint**                       | **Хэш-код для идентификации идентичных нормализованных запросов.**                                                                                                     |
| **query**                  | **text**                         | **Текст заявления представителя**                                                                                                                                      |
| **plans**                  | **bigint**                       | **Количество запланированных операций (если pg_stat_statements.track_planning включено, иначе ноль)**                                                                  |
| **total_plan_time**        | **double precision**             | **Общее время, затраченное на планирование выписки, в миллисекундах (если pg_stat_statements.track_planning включено, иначе ноль)**                                    |
| **min_plan_time**          | **double precision**             | **Минимальное время, затраченное на планирование выписки, в миллисекундах (если pg_stat_statements.track_planning включено, иначе ноль)**                              |
| **max_plan_time**          | **double precision**             | **Максимальное время, затрачиваемое на планирование выписки, в миллисекундах (если pg_stat_statements.track_planning включено, иначе ноль)**                           |
| **mean_plan_time**         | **double precision**             | **Среднее время, затраченное на планирование выписки, в миллисекундах (если pg_stat_statements.track_planning включено, иначе ноль)**                                  |
| **stddev_plan_time**       | **double precision**             | **Стандартное отклонение совокупности времени, затраченного на планирование оператора, в миллисекундах (если pg_stat_statements.track_planning включено, иначе ноль)** |
| **calls**                  | **bigint**                       | **Сколько раз оператор был выполнен**                                                                                                                                  |
| **total_exec_time**        | **double precision**             | **Общее время, затраченное на выполнение оператора, в миллисекундах**                                                                                                  |
| **min_exec_time**          | **double precision**             | **Минимальное время, затраченное на выполнение оператора, в миллисекундах**                                                                                            |
| **max_exec_time**          | **double precision**             | **Максимальное время, затраченное на выполнение оператора, в миллисекундах**                                                                                           |
| **mean_exec_time**         | **double precision**             | **Среднее время, затрачиваемое на выполнение оператора, в миллисекундах**                                                                                              |
| **stddev_exec_time**       | **double precision**             | **Стандартное отклонение населения времени, затраченного на выполнение оператора, в миллисекундах**                                                                    |
| **rows**                   | **bigint**                       | **Общее количество строк, извлеченных или затронутых оператором**                                                                                                      |
| **shared_blks_hit**        | **bigint**                       | **Общее количество попаданий в общий кэш блоков оператором**                                                                                                           |
| **shared_blks_read**       | **bigint**                       | **Общее количество общих блоков, прочитанных инструкцией**                                                                                                             |
| **shared_blks_dirtied**    | **bigint**                       | **Общее количество общих блоков, испорченных оператором**                                                                                                              |
| **shared_blks_written**    | **bigint**                       | **Общее количество общих блоков, записанных оператором**                                                                                                               |
| **local_blks_hit**         | **bigint**                       | **Общее количество попаданий в локальный кэш блоков оператором**                                                                                                       |
| **local_blks_read**        | **bigint**                       | **Общее количество локальных блоков, прочитанных оператором**                                                                                                          |
| **local_blks_dirtied**     | **bigint**                       | **Общее количество локальных блоков, испорченных оператором**                                                                                                          |
| **local_blks_written**     | **bigint**                       | **Общее количество локальных блоков, записанных оператором**                                                                                                           |
| **temp_blks_read**         | **bigint**                       | **Общее количество временных блоков, прочитанных оператором**                                                                                                          |
| **temp_blks_written**      | **bigint**                       | **Общее количество временных блоков, записанных оператором**                                                                                                           |
| **blk_read_time**          | **double precision**             | **Общее время, затраченное оператором на чтение блоков файла данных, в миллисекундах (если включена функция track_io_timing , иначе ноль)**                            |
| **blk_write_time**         | **double precision**             | **Общее время, затраченное оператором на запись блоков файла данных, в миллисекундах (если включена функция track_io_timing , иначе ноль)**                            |
| **temp_blk_read_time**     | **double precision**             | **Общее время, затраченное оператором на чтение блоков временного файла, в миллисекундах (если включена функция track_io_timing , иначе ноль)**                        |
| **temp_blk_write_time**    | **double precision**             | **Общее время, затраченное оператором на запись блоков временного файла, в миллисекундах (если включена функция track_io_timing , иначе ноль)**                        |
| **wal_records**            | **bigint**                       | **Общее количество записей WAL, сгенерированных оператором**                                                                                                           |
| **wal_fpi**                | **bigint**                       | **Общее количество полностраничных изображений WAL, сгенерированных оператором**                                                                                       |
| **wal_bytes**              | **numeric**                      | **Общий объем WAL, сгенерированный оператором, в байтах**                                                                                                              |
| **jit_functions**          | **bigint**                       | **Общее количество функций, JIT-компилируемых оператором**                                                                                                             |
| **jit_generation_time**    | **double precision**             | **Общее время, затрачиваемое оператором на генерацию JIT-кода, в миллисекундах**                                                                                       |
| **jit_inlining_count**     | **bigint**                       | **Сколько раз функции были встроены**                                                                                                                                  |
| **jit_inlining_time**      | **double precision**             | **Общее время, затрачиваемое оператором на встраивание функций, в миллисекундах**                                                                                      |
| **jit_optimization_count** | **bigint**                       | **Сколько раз выражение было оптимизировано**                                                                                                                          |
| **jit_optimization_time**  | **double precision**             | **Общее время, затраченное оператором на оптимизацию, в миллисекундах**                                                                                                |
| **jit_emission_count**     | **bigint**                       | **Количество генерируемых кодов**                                                                                                                                      |
| **jit_emission_time**      | **double precision**             | **Общее время, затраченное оператором на генерацию кода, в миллисекундах**                                                                                             |