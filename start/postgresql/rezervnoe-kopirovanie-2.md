---
order: 5
title: Резервное копирование
---

## Настройка и выполнение резервного копирования

Перед выполнением копирования следует обратить внимание, что утилиты pg_dump и pg_dumpall создают логическую копию, которая не содержит информации для дальнейшего воспроизведения журнала транзакций и не подходит для решения задачи восстановления Point-in-Time.

## **1\. Выгрузка базы данных или отдельных таблиц с помощью pg_dump**

-  Можно выполнить в виде скрипта или в архивном формате.

-  Возможно использовать многопоточность, в зависимости от выбранного формата.

-  Не содержит индексы, рекомендуется выполнить analyze после восстановления.

-  Копия, созданная через утилиту **pg_dump**, будет консистентна на начало формирования бекапа.

-  Нет возможности восстановления на момент времени PITR (Point-in-time recovery, PITR).

-  **Подходит для переноса между различными операционными и файловыми системами.**

Основные форматы, которые используются при создании через **pg_dump:**

-  plain

   -  Выполняется однопоточно.

   -  Можно подключить многопоточный архиватор.

   -  Можно использовать для восстановления на MS SQL.

   -  Выгружается в виде SQL-скрипта.

   -  Отключать реплики не требуется.

-  custom

   -  Выполняется однопоточно, восстановление может выполняться многопоточно.

   -  Можно добавить сжатие при выгрузке.

   -  Отключать реплики не требуется.

-  directory

   -  Может выполняться многопоточно.

   -  Сохраняет каждую таблицу в отдельный архив, выгружается в формате каталога.

   -  Можно добавить сжатие при выгрузке.

   -  Требуется отключать реплику перед созданием.

Пример команды для Windows:

**pg_dump -h 127.0.0.1 -U postgres -F p -f C:\\backup.sql test_base**

где:

-  \-h 127.0.0.1, - адрес сервера.

-  \-U postgres, - имя пользователя, под которым производится подключение.

-  \-F p, - формат вывода копии, "p" = plain, "с" = custom, "d" = directory.

-  \-f C:\\backup.sql, - файл для сохранения копии.

-  test_base\*\*, -\*\*имя копируемой базы.

Пример команды для Linux:

**pg_dump -h 127.0.0.1 -U postgres -F p -f /tmp/backup.sql test_base**

Если необходимо выгрузить базу данных 1С:Предприятия в следующем виде:

-  полную структуру таблиц (без данных)

-  конфигурацию

-  часть таблиц с данными

То необходимо сначала выгрузить схему данных:

**pg_dump -h 127.0.0.1 -U postgres --schema-only -F p -f C:\\schema.sql testbase**

Затем, выгрузить данные необходимых таблиц:

**pg_dump -h 127.0.0.1 -U postgres --format=p -b --dbname=testbase --clean --if-exists -t YearOffset -t Config -t ConfigCAS -t ConfigCASSave -t ConfigSave -t DBSchema -t DepotFiles -t Files -t IBVersion -t Params -t SchemaStorage | sed '/^users\[.\]usr/d' > C:\\data.sql**

## **2\. Резервное копирование с помощью pg_basebackup**

**Утилита pg_basebackup создает копию всего инстанса, но для восстановления копии на опеределенный момент времени требуется** наличие непрерывной последовательности архивированных файлов WAL, начинающихся не позднее момента создания файловой резервной копии.

Наличие непрерывной последовательности архивированных файлов WAL позволит после восстановления данных из воспроизвести журнал на нужный момент времени и привести систему в состояние на этот момент.

-  **Копируется весь кластер, однако нет возможности** выполнить в разрезе баз данных и таблиц.

-  Выполняется однопоточно.

-  Копия, выполненная через утилиту **pg_basebackup**, будет консистентна на конец выполнения операции.

-  Рекомендуется выполнить analyze после восстановления.

-  **Не подходит для переноса между различными операционными и файловыми системами.**

-  Не копирует настройки инстанса, если они располагаются в отдельном от инстанса каталоге.

   Например, в Linux настройки инстанса могут храниться в каталоге /etc/postgresql, при этом сам инстанс может быть расположен в /var/lib/postgresql.

### **2\.1** Включение архивирования WAL на уровне сервера

В конфигурационном файле **postgresql.conf** меняем настройки:

**wal_level = replica**

**archive_mode = on**

**archive_command = 'copy "%p" "C:\\\\PostgreSQLBackup\\\\%f"'**

\- команда, которая будет выполняться при архивировании WAL в момент переключения на  его следующий сегмент.

Параметр %p автоматически заменяется полным путём к файлу, подлежащему архивации (...\\pg_wal), а %f  - именем файла.  C:\\PostgreSQLBackup\\ в данном примере - путь к директории, куда будет производиться архивирование WAL.

В качестве archive_command может быть также указан скрипт, описывающий более сложную логику операций - архивирование файлов, пакетная передача и др., например:

**archive_command = 'local_backup\_**[**script.sh**](http://script.sh) **"%p" "%f"'**

В случае, если переключение на следующий сегмент лога и последующее архивирование происходит слишком редко ввиду невысокой интенсивности работы кластера, можно установить значение параметра:

**archive_timeout=60**

\- период в секундах, по достижении которого переключение на новый сегмент произойдет принудительно.

**max_wal_senders=5**

(значение по умолчанию - 0, значение 5 указано в качестве примера и технически может быть любым, отличным от 0)

Необходимо обратить внимание, что в случае, если для кластера существует hot_standby -реплика, которая уже является получателем WAL-архивов, значение параметра **max_wal_senders**, определяющего количество процессов, выполняющих передачу WAL, должно быть не менее 2. В конфигурационном файле pg_hba.conf разрешаем пользователю, под которым будет выполняться архивирование, подключение для репликации:

**host replication     postgres        ::1/128  md5**

**host replication     postgres         127.0.0.1/32 md5**

Выполняем перезапуск службы сервера.

### 2\.2 Создание базовых резервных копий

Интервал создания копии выбирается индивидуально исходя из того, сколько места на диске может быть выделено для хранения файлов WAL, и их размера - необходимо будет хранить все файлы с момента создания последней резервной копии. Копии в примере будут создаваться с помощью утилиты  **pg_basebackup** (подробно об ее использовании и опциях можно прочитать в документации PostgreSQL <https://www.postgresql.org/docs/15/app-pgbasebackup.html>). Выполнять резервное копирование можно без остановки работы кластера, однако процесс может привести к повышенной нагрузке на CPU и дисковую подсистему, поэтому лучше делать это в периоды с наименьшей нагрузкой.

Если для кластера включена hot_standby-реплика, лучше использовать именно её для создания резервных копий, чтобы не нагружать master-сервер.  Алгоритм выполнения на ведомом сервере будет таким же, но есть несколько настроек, которые необходимо дополнительно выполнить на slave-сервере (описаны в документации к утилите **pg_basebackup**).

Создаем копию:

**pg_basebackup -D "D:\\Backup" -X fetch -F tar**

-  \-D,  - директория, куда будет скопировано содержимое каталога ..\\data.  Она должна быть пустой

-  \-F,  - формат. В данном примере значение tar означает, что содержимое будет добавлено в архив

-  \-X,  - метод копирования файлов WAL, созданных в процессе создания копии. Значение fetch означает, что файлы будут скопированы в конце процесса.

## Выполнение восстановления

Перед восстановление копии следует помнить о том, что:

-  копии, снятые с помощью утилиты pg_dump восстанавливаются с помощью утилит psql и pg_restore.

   **такие копии возможно восстановить как в Linux, так и в Windows.**

-  копии, снятые с помощью утилиты **pg_basebackup не требуют утилит для восстановления, т.к. представляют собой копию кластера.**

   **копию снятую через pg_basebackup в Linux невозможно развернуть в Windows и наоборот.**

## **1\. Восстановление базы данных или отдельных таблиц с помощью** pg_restore

Для того, чтобы избежать коллизий перед восстановлением бекапа рекомендуется удалить целевую базу, если она уже существует.

Далее нужно создать новую базу, но перед созданием базы необходимо учитывать следующее: локаль базы должна совпадать с локалью кластера.

Узнать локаль кластера можно командой:

**show lc_collate;**

Пример команды инициализации кластера с указанием локали и кодировки для Windows:

**initdb.exe -D C:\\PostgreSQL-15 --locale=russian_Russia --encoding=UTF8;**

для Linux:

**initdb -D /var/lib/postgresql/15/main --locale=ru_RU.utf8 --encoding=UTF8;**

-  \-D, - директория данных кластера.

Если кластер инициализирован, то создать базу можно следующей командой для Windows:

**CREATE DATABASE testbase --locale=russian_Russia --encoding=UTF8;**

для Linux:

**CREATE DATABASE testbase --locale=ru_RU.utf8 --encoding=UTF8;**

Для восстановления копии, сделанной в формате "plain", необходимо использовать утилиту psql, а не pg_restore, т.к. копия в формате "plain" представляет собой набор команд sql.

**psql -h 127.0.0.1 -p 5432 -U postgres -d testbase -f C:\\backup.sql**

-  \-h 127.0.0.1, - адрес сервера.

-  \-p 5432, - порт сервера.

-  \-U postgres, - имя пользователя, под которым производится подключение.

-  \-d testbase, - имя базы, в которую выполняется восстановление.

-  \-f C:\\backup.sql, - файл восстанавливаемой копии.

Пример команды для восстановления копии из формата "custom" и "directory":

**pg_restore -h 127.0.0.1 -p 5432 -U postgres -d testbase C:\\backup**

где:

-  \-h 127.0.0.1, - адрес сервера.

-  \-U postgres, - имя пользователя, под которым производится подключение.

-  \-d testbase, - имя базы данных, в которую будет восстановлена копия.

-  \-f C:\\backup, - файл восстанавливаемой  копии.

Чтобы восстановить базу, которая была выгружена в виде схемы данных и таблиц, то необходимо выполнить две команды:

**psql -h server -U postgres -d testbase C:\\schema.sql**

**psql -h server -U postgres -d testbase C:\\data.sql**

Иногда бывает полезным выполнить загрузку в одной транзакции и с контролем наличия ошибок. Тогда будет остановка при первой ошибке:\
**psql -U postgres -h server -d testbase -1 -f database.sql -v ON_ERROR_STOP=1**

Распространенные ошибки и способы их решения:

-  Создание новой информационной базы для восстановления через консоль кластера 1С.

   При восстановлении в такую информационную базу появятся ошибки следующего вида:

   **pg_restore: error: could not execute query: ERROR: relation "byshow" already exists**

   **Command was: CREATE INDEX byshow ON public.v8users USING btree (show);**

   Необходимо создать новую информационную базу через утилиту psql.

-  При попытке восстановить копию, сделанную в формате "plain" через pg_restore появится ошибка:

   **pg_restore: error: input file appears to be a text format dump. Please use psql.**

   Необходимо использовать утилиту psql.

-  При попытке восстановить копию информационной базы, владельцем которой является пользователь, которого нет в целевом инстансе, появится ошибка вида:

   

-  **pg_restore: error: could not execute query: ERROR: role "usr1cv8" does not exist**

   Для исправления этой ошибки необходимо добавить параметр --no-owner:

   **pg_restore --no-owner -h 127.0.0.1 -p 5432 -U postgres -d testbase C:\\backup**

-  Если в информационной базе для восстановления копии не установлены расширения mchar, fulleq и fasttrun, то при восстановлении появятся ошибки:

   **pg_restore: error: could not execute query: ERROR: extension "mchar" does not exist**

   **pg_restore: error: could not execute query: ERROR: extension "fulleq" does not exist**

   **pg_restore: error: could not execute query: ERROR: extension "fasttrun" does not exist**

   Необходимо установить указанные расширения в информационную базу перед восстановлением копии командой:

   **create extension fasttrun;**

   **create extension fulleq;**

   **create extension mchar;**

## **2\. Восстановление копии с помощью pg_basebackup**

Для выполнения восстановления с использованием полной резервной копии и архива WAL необходимо:

1\. Остановить сервер баз данных PostgreSQL.

2\. Сделать копию текущего каталог кластера PostgreSQL на всякий случай, т.к. копия, созданная через **pg_basebackup** может быть без настроек инстанса. Для таких случаев поможет копия текущего инстанса.

3\. Удалить содержимое текущего каталога кластера баз данных (...\\data).

4\. Восстановить (скопировать) файлы необходимой архивной копии, созданной ранее, в текущий каталог данных кластера (…\\data).

5\. Файлы WAL в директории \\pg_wal нужно удалить.

6\. Если требуется только восстановить копию, то можно переходить к пункту 7. В этом случае кластер будет соответствовать состоянию на момент создания базовой резервной копии.

Если же требуется восстановить копию с учетом всех изменений, которые произошли после создания базовой резервной копии, то необходимо создать файл **recovery.signal** и в файле **postgresql.conf** выполнить настройку:

**restore_command = 'copy "C:\\\\PostgreSQLBackup\\\\%f" "%p"'**

\- команда, которая будет выполняться для получения созданных ранее архивов WAL (действие, обратное выполняемому командой archive_command в postgresql.conf). Важно, чтобы в случае ошибки restore_command возвращала ненулевой код. По аналогии с archive_command,  можно указать в качестве команды скрипт с более сложной логикой.

После запуска сервера получение архивов и их воспроизведение (с помощью команды выше) по умолчанию будет выполняться до последнего файла WAL. Если нужно выполнить восстановление на конкретную точку, то необходимо в файле **postgresql.conf** указать:

**recovery_target_time = '2018-03-15 12:00:00'**

Или для восстановления на именованную точку:

**recovery_target_name = 'our_label'**

Такую точку можно создать, например, выполнив в контексте любой из баз кластера запрос:

**select pg_create_restore_point('our_label');**

7\. Запустить сервер баз данных.

Сервер будет запущен в режиме восстановления (recovery) и начнет обработку файлов WAL.  По завершении сервер удалит файл **recovery.signal** и начнет работать в обычном режиме, в том числе разрешит подключения к нему.  Если на время выполнения проверки после восстановления нужно запретить соединения с сервером, это лучше всего сделать в конфигурационном файле pg_hba.conf.

## Обеспечение возможности быстрого возврата системы в состояние "до изменений"

В процессе эксплуатации часто возникает необходимость перед выполнением каких-либо изменений системы обеспечить возможность их быстрой отмены. При этом создание дополнительного полного бэкапа не всегда возможно (например, могут быть ограничены ресурсы файлового хранилища, процесс копирования может занимать слишком длительное время и др.). По сути для корректного возврата системы в требуемый момент времени необходимо, чтобы в точке восстановления все изменения в базе данных были сброшены на диск и выполнился checkpoint - контрольная точка.

Один из самых простых возможных сценариев решения такой задачи предполагает использование функции резервного копирования **pg_start_backup()**, которая вместе с **pg_stop_backup()** используется в утилите **pg_basebackup**, описанной выше, с той разницей, что утилита автоматически выполняет физическое копирование кластера в соответствии с параметрами, а ручной вызов возлагает ответственность за создание копии на администратора системы и позволяет физическое копирование "пропустить".

Перед выполнением изменений системы :

1\. Убеждаемся, что архивирование WAL включено.

2\. Подключаемся к серверу баз данных в контексте любой из баз и выполняем запрос:

**select pg_backup_start('our_label', true);**

Первым параметром указываем имя метки, которое потом будем использовать при восстановлении. Второй параметр означает, что checkpoint будет осуществлен как можно скорее независимо от настроек параметра checkpoint_completion_target.

Далее мы как раз должны были бы выполнить копирование каталога данных, но в данном случае это нам не нужно - можно приступить к плановым изменениям. Перед этим целесообразно сделать снимок виртуальной машины - это не требует много ресурсов, но повысит надежность. Кроме того, снимок можно будет быстро развернуть в тестовом контуре, если это потребуется (конечно же, это никак не заменяет регулярные полные бэкапы кластера).

В случае необходимости отката изменений далее действия не будут отличаться от алгоритма восстановления, описанного выше, за тем исключением, что не нужно удалять каталог кластера и копировать на его место резервную копию - достаточно просто запустить сервер в режиме восстановления, создав файл **recovery.signal** и указав в файле **postgresql.conf** созданную метку в качестве **recovery_target_name**.

Если отмену делать не нужно, выводим сервер из режима резервного копирования, выполнив:



**select pg_stop_backup();**